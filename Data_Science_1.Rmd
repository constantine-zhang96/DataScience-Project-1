---
title: "Data Science Project 1"
author:
- Constantine Zhang
- Ha Nguyen
- Kemal Ege Sural
date: '`r Sys.Date()`'
output:
  html_document:
    code_folding: hide
    number_sections: false
    toc: true
    toc_depth: 3
    toc_float: true
  pdf_document:
    toc: true
    toc_depth: '3'
---

# Lietrature Review




# Setup
```{r setup, include=FALSE}
knitr::opts_chunk$set(results="markup", warning = F, message = F,
                      fig.width=8, fig.height=6, fig.dim=c(8,6), fig.align='center')
options(scientific=T, digits = 4,scipen = 999)
```

```{r library, include = FALSE}
library(ggplot2)
library(dplyr)
library(tidyr)
library(tinytex)
library(kableExtra)
library(scales)
library(patchwork)
library(tibble)
library(gt)
library(webshot2)
```

```{r data import and cleaning na value, include = FALSE}
data_counties <- read.csv("introdata_merged_counties.csv")
data_counties %>% drop_na()
```


# Summary and preview data set

```{r preview data}
tmp <- head(data_counties, 5)
names(tmp) <- c("County FIPS","State","County",
                "Per-Capita Income (2019)","Per-Capita Income (2020)","Per-Capita Income (2021)",
                "Associate Degrees (Count, 2016–2020)","Bachelor’s Degrees (Count, 2016–2020)",
                "Associate Degrees (%)","Bachelor’s Degrees (%)",
                "Population (Est.)","Population (Male)","Population (Female)",
                "Under 5 (Count)","Age 18+ (Count)","Age 65+ (Count)","Median Age")

kable(tmp, caption = "Table 1. First 5 rows of counties data",
      format = "html", align = "c") |>
  kableExtra::kable_styling(bootstrap_options = c("striped","hover","condensed"),
                            full_width = FALSE, position = "center") |>
  kableExtra::scroll_box(width = "100%", height = "300px")
```

```{r}
names(data_counties)
```

The provided dataset offers detailed information for U.S. counties in three main categories. First, Economic Data tracks the average income for each person in the county (Per-Capita Personal Income) across three specific years: 2019, 2020 and 2021. Second, Education Data focuses on the attainment of residents, listing both the raw counts and calculated percentages of people with an Associate Degree and a Bachelor’s Degree. Third, Demographic Data covers basic population facts, including the total population (POPESTIMATE), the number of people in different age groups (like 18+ or 65+) and the median age, with each county being uniquely identified by its FIPS code. This allows the project to compare how a county's level of education relates to its economic health.


```{r data set summary}
summary(data_counties)
```
```{r Per Capita Personal Income Distribution by State (2020)}

state_income <- data_counties %>%
  group_by(state) %>%
  summarize(median_income = median(per_capita_personal_income_2020, na.rm = TRUE))

state_income <- state_income %>%
  mutate(income_group = ntile(median_income, 3))

set.seed(42)  
sample_states <- state_income %>%
  group_by(income_group) %>%
  slice_sample(n = 5) %>%
  pull(state)


data_counties_filtered <- data_counties %>%
  filter(state %in% sample_states)


ggplot(data_counties_filtered, 
       aes(x = reorder(state, per_capita_personal_income_2020, FUN = median),
           y = per_capita_personal_income_2020,
           fill = state)) +
  geom_boxplot() +
  coord_flip() +
  theme_minimal() +
  theme(legend.position = "none") +
  labs(
    title = "Per Capita Personal Income Distribution by States (2020)",
    
    x = "State",
    y = "Per Capita Personal Income (2020)"
  )
```
The box plot displays the distribution of Per Capita Personal Income at the county level for 15 states chosen as a balanced sample across low, medium and high state-level incomes. The sorting is done by the median income of the counties within each state, placing Georgia (GA) at the bottom and North Dakota (ND) at the top. The colored boxes represent the central 50% of county incomes, with Colorado (CO) showing the greatest range. The outliers, representing specific counties with incomes far outside the typical range for that state, such as extremely wealthy county in Colorado. 


# Data cleaning

## Calculate Percentage for education level

```{r calculate bachelor and associate degree percentage for working age population in 2020}
data_counties$bachelor_degree_percentage_2016_2020 <- data_counties$bachelor_degree_numbers_2016_2020/(data_counties$AGE18PLUS_TOT - data_counties$AGE65PLUS_TOT)  * 100

data_counties$associate_degree_percentage_2016_2020Test <- data_counties$associate_degree_numbers_2016_2020/(data_counties$AGE18PLUS_TOT- data_counties$AGE65PLUS_TOT) * 100

```
We calculated the percentage of bachelor and associate degree percentage in terms of working age population for 2016 to 2020. We define working age population as person who's age is between 18 and 65. 

<<<<<<< HEAD
```
```{r qqlot associate 2020}
associate2020_qqplots <- qqnorm(data_counties$associate_degree_numbers_2016_2020,
                         main = "QQ Plot of Associate degree number 2016 - 2020",
                         xlab = "Theoretical Quantiles",
                         ylab = "Sample Quantiles",
                         plot.it = TRUE,
                         datax = FALSE)
qqline(data_counties$associate_degree_numbers_2016_2020, 
       col = 2,
       lwd = 2)
```


```{r}
ggplot(data_counties, aes(x = bachelor_degree_numbers_2016_2020, y = per_capita_personal_income_2020 )) +
  geom_point() +
  theme_minimal() +
  labs(
    title = "Bachelor’s Degree Numbers vs. Per Capita Personal Income (2020) Scatter Plot",
    x = "Number of Bachelor's Degree 2016-2020",
    y = "Personal Income Per Capita (2020)"
  ) 

ggplot(data_counties, aes(x = associate_degree_numbers_2016_2020 , y = per_capita_personal_income_2020 )) +
  geom_point() +
  theme_minimal() +
  labs(
    title = "Associate’s Degree Numbers vs. Per Capita Personal Income (2020) Scatter Plot",
    x = "Number of Associate's Degree 2016-2020",
    y = "Personal Income Per Capita (2020)"
  ) 

```
**Result Analysis**

All three QQ plots scream non-normal with a strong right tail. That’s expected at county level.

- Per-capita income (2020): points bend above the line in the upper tail → positive skew / heavy right tail (a few very high-income counties). Mild deviation in lower tail.

- Bachelor/Associate numbers (2016–2020): extreme curvature and long upper tails. Many dots are piled near zero → lots of small counties + a few huge metros. These are counts, so non-normality is almost guaranteed.

The raw  variable is non-normal. This does not invalidate parametric procedures per se (especially with large samples), but it suggests:

- potential heteroskedasticity across groups,

- inflated influence of extreme values,

# Identify the extreme value
=======
## Remove extreme value (1.5 IQR method)
>>>>>>> ec0dd7bb45b874566af651c7b2441e749ff49124

To determine the extreme values to smoothen the distribution of income, we exclude extreme value using the IQR method to define the upper and lower bound and and flagged any value outside the bound.

```{r remove extreme value for income}
data_counties_No_Outliers <- data_counties %>%
  select(state, county_FIPS, county,
         per_capita_personal_income_2019,
         per_capita_personal_income_2020,
         per_capita_personal_income_2021) %>%
  pivot_longer(
    cols = starts_with("per_capita_personal_income_"),
    names_to = "year",
    values_to = "income"
  ) %>%
  mutate(year = as.integer(sub(".*_(\\d{4})$", "\\1", year)))

data_counties_No_Outliers <- data_counties_No_Outliers %>%
  group_by(year) %>%
  mutate(
    Q1 = quantile(income, 0.25, na.rm = TRUE),
    Q3 = quantile(income, 0.75, na.rm = TRUE),
    IQRv = Q3 - Q1,
    lo = Q1 - 1.5 * IQRv,
    hi = Q3 + 1.5 * IQRv
  ) %>%
  ungroup() %>%
  filter(income >= lo, income <= hi) %>%
  select(-Q1, -Q3, -IQRv, -lo, -hi)

data_counties_No_Outliers <- data_counties_No_Outliers %>%
  pivot_wider(
    names_from = year,
    values_from = income,
    names_prefix = "No_Outlier_per_capita_personal_income_"
  )  %>%
  drop_na()

data_counties <- data_counties %>%
  left_join(data_counties_No_Outliers, by = c("state", "county_FIPS", "county"))

rm(data_counties_No_Outliers)
```

### Ditrubution plot after removing extreme value
```{r plot distribution}

x_limits <- c(20000, 80000)
x_breaks <- seq(20000, 80000, by = 10000)

# 2020 histogram
p2020 <- ggplot(data_counties, 
                aes(x = No_Outlier_per_capita_personal_income_2020)) +
  geom_histogram(bins = 40, fill = "#2ca02c", color = "white", alpha = 0.9) +
  scale_x_continuous(labels = comma, limits = x_limits, breaks = x_breaks) +
  labs(title = "2020", x = "Income (USD)", y = "Count") +
  theme_minimal(base_size = 13) +
  theme(plot.title = element_text(face = "bold", hjust = 0.5))


p2020 <- p2020 +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p2020

```

After removing IQR outliers, the histograms by year become noticeably more symmetric and centered, indicating that a small number of very high-income counties were driving the skew


# EDA

## Normality test 

**Objective**
Assess whether the distribution of per-capita personal income (2019–2021) is approximately Normal, and decide how to proceed for hypothesis testing method for the next parts

**Method**

We evaluated normality using: quantile–quantile (QQ) plots against the Normal distribution

**Plotting**

```{r qqlot income 2020}
income2020_qqplots <- qqnorm(data_counties$per_capita_personal_income_2020,
                         main = "QQ Plot of Personal Income Per Capita in 2020",
                         xlab = "Theoretical Quantiles",
                         ylab = "Sample Quantiles",
                         plot.it = TRUE,
                         datax = FALSE)
qqline(data_counties$per_capita_personal_income_2020, 
       col = 2,
       lwd = 2)

```
Our QQ plot suggests the presence of observations with unusually high income levels, indicating potential outliers in the upper tail of the distribution.

```{r qqlot bachelor 2020}
bachelor2020_qqplots <- qqnorm(data_counties$bachelor_degree_percentage_2016_2020,
                         main = "QQ Plot of Bachelor degree percentage for working age population 2016 - 2020",
                         xlab = "Theoretical Quantiles",
                         ylab = "Sample Quantiles",
                         plot.it = TRUE,
                         datax = FALSE)
qqline(data_counties$bachelor_degree_percentage_2016_2020, 
       col = 2,
       lwd = 2)

```
Our qqplot for bachelor degree percentage demonstrate a deviation from our line at both lower and upper tail of the graph, this also suggests us that there exist outliers in both ends for our sample data. 


```{r qqlot associate 2020}
associate2020_qqplots <- qqnorm(data_counties$associate_degree_percentage_2016_2020Test,
                         main = "QQ Plot of Associate degree percentage for working age population 2016 - 2020",
                         xlab = "Theoretical Quantiles",
                         ylab = "Sample Quantiles",
                         plot.it = TRUE,
                         datax = FALSE)
qqline(data_counties$associate_degree_percentage_2016_2020Test, 
       col = 2,
       lwd = 2)
```
This qqplot imply that we have a approximately normally distributed sample data for the associate degree precentage. 



**Result Analysis**

All three QQ plots scream non-normal with a strong right tail. That’s expected at county level.

What the plots show

Per-capita income (2020): points bend above the line in the upper tail → positive skew / heavy right tail (a few very high-income counties). Mild deviation in lower tail.

Bachelor/Associate numbers (2016–2020): extreme curvature and long upper tails. Many dots are piled near zero → lots of small counties + a few huge metros. These are counts, so non-normality is almost guaranteed.

The raw  variable is non-normal. This does not invalidate parametric procedures per se (especially with large samples), but it suggests:

- potential heteroskedasticity across groups,

- inflated influence of extreme values,




### Normality test after remove the extreme value
```{r new qqplot 2020}
income2020_qqplots_NoOut <- qqnorm(data_counties$No_Outlier_per_capita_personal_income_2020,
                         main = "QQ Plot of Personal Income Per Capita in 2020, with no Outliers",
                         xlab = "Theoretical Quantiles",
                         ylab = "Sample Quantiles",
                         plot.it = TRUE,
                         datax = FALSE)
qqline(data_counties$No_Outlier_per_capita_personal_income_2020, 
       col = 2,
       lwd = 2)
```

**Result Analysis**

For per-capita personal income in 2020, the extreme values are predominantly on the high side (right tail), which is consistent with the QQ plots (heavy upper tail).



These extreme values likely reflect genuine high-income counties rather than data entry errors (they are consistent across years and align with known distributional features of income).

We will not be removing extreme value in our education level data because we will be using percentage data so the extreme value can not influence the data distribution that much and we can use log function to further smooth the distribution. 



## Bar chart for comparison 

We want to see how each state is doing compare the the overall average value.

For this project, we will be focus on the per capita personal income of 2020 and the corresponding education level percentage data. 

**Method**

Our method for this visualization is simple: since we already have state indicator variables for our counties data, we group by state and calculate mean value for each state and store these value in a new data set. We then calculate the overall average which is represented by the horizontal red line in each of the bar charts. 


### Bar chart for per capita personal income state leve 2020
```{r  distribution of per capita income in 2020 for each state compare the mean}
data_counties$state <- as.factor(data_counties$state)


state_means <- data_counties %>%
  group_by(state) %>%
  summarize(mean_income = mean(per_capita_personal_income_2020, na.rm = TRUE))

state_means_No_Outliers <- data_counties %>%
  group_by(state) %>%
  summarize(mean_income = mean(No_Outlier_per_capita_personal_income_2020, na.rm = TRUE))

ggplot(state_means, aes(x = reorder(state, mean_income), y = mean_income)) +
  geom_col(fill = "skyblue") + 
  geom_hline(aes(yintercept = mean(mean_income, na.rm = TRUE)), 
             color = "red", 
             linetype = "dashed", 
             linewidth = 1) +
  labs(title = "Mean Income by State in 2020",
       x = "State",
       y = "Mean Income") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 60, hjust = 1, size = 8)
  )


ggplot(state_means_No_Outliers, aes(x = reorder(state, mean_income), y = mean_income)) +
  geom_col(fill = "skyblue") +
  geom_hline(aes(yintercept = mean(mean_income, na.rm = TRUE)), 
             color = "red", 
             linetype = "dashed", 
             linewidth = 1) +
  labs(title = "Mean income without Outliers",
       x = "State",
       y = " Bachelor degree numbers") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 8))
```


### Bar chart for bachelor degree percentage state level 2020 
```{r}

state_means_bachelor <- data_counties %>%
  group_by(state) %>%
  summarize(bachelor_degree_percentage = mean(bachelor_degree_percentage_2016_2020, na.rm = TRUE))


ggplot(state_means_bachelor, aes(x = reorder(state, bachelor_degree_percentage), y = bachelor_degree_percentage)) +
  geom_col(fill = "skyblue") +
  geom_hline(aes(yintercept = mean(bachelor_degree_percentage, na.rm = TRUE)), 
             color = "red", 
             linetype = "dashed", 
             linewidth = 1) +
  labs(title = "percentage of bachelor degree from 2016-2020 by State",
       x = "State",
       y = " Bachelor degree percentage") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 8))


```


### Bar chart for associate degree percentage state level 2020
```{r}

state_means_associate <- data_counties %>%
  group_by(state) %>%
  summarize(associate_degree_percentage = mean(associate_degree_percentage_2016_2020Test, na.rm = TRUE))



ggplot(state_means_associate, aes(x = reorder(state, associate_degree_percentage), y = associate_degree_percentage)) +
  geom_col(fill = "skyblue") +
  geom_hline(aes(yintercept = mean(associate_degree_percentage, na.rm = TRUE)), 
             color = "red", 
             linetype = "dashed", 
             linewidth = 1) +
  labs(title = "Percentage of Associate degree from 2016-2020 by State",
       x = "State",
       y = " Associate degree percentage") +
  
  theme_minimal() + 
  theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 8))


```


## Calculate the 95% CI

```{r  finding Confidence Intervals for income, degree, population}
per_capita_2019_ttest <- t.test(x=data_counties$per_capita_personal_income_2019, conf.level=0.95)
per_capita_2019_ci_95 <- per_capita_2019_ttest$conf.int

per_capita_2020_ttest <- t.test(x=data_counties$per_capita_personal_income_2020, conf.level=0.95)
per_capita_2020_ci_95 <- per_capita_2020_ttest$conf.int

per_capita_2021_ttest <- t.test(x=data_counties$per_capita_personal_income_2021, conf.level=0.95)
per_capita_2021_ci_95 <- per_capita_2021_ttest$conf.int

bachelor_ttest <- t.test(x=data_counties$bachelor_degree_percentage_2015_2019, conf.level=0.95)
bachelor_ci_95 <- bachelor_ttest$conf.int

associate_ttest <- t.test(x=data_counties$associate_degree_percentage_2016_2020, conf.level=0.95)
associate_ci_95 <- associate_ttest$conf.int

population_ttest <- t.test(x=data_counties$POPESTIMATE, conf.level=0.95)
population_ci_95 <- population_ttest$conf.int
```

```{r finding Confidence interval for age}
median_age_ttest <- t.test(x=data_counties$MEDIAN_AGE_TOT, conf.level=0.95)
median_age_ci_95 <- median_age_ttest$conf.int

share5 <- data_counties$UNDER5_TOT/data_counties$POPESTIMATE
share5_population <- sum(data_counties$UNDER5_TOT,na.rm = TRUE)/sum(data_counties$POPESTIMATE,na.rm = TRUE)
share_5_ttest <- t.test(x=share5, conf.level=0.95)
share_5_ci_95 <- share_5_ttest$conf.int

share65 <- data_counties$AGE65PLUS_TOT/data_counties$POPESTIMATE
share65_population <- sum(data_counties$AGE65PLUS_TOT,na.rm = TRUE)/sum(data_counties$POPESTIMATE,na.rm = TRUE)
share_65_ttest <- t.test(x=share65, conf.level=0.95)
share_65_ci_95 <- share_65_ttest$conf.int
```

```{r make into table}
num1 <- function(x) as.numeric(unname(x))[1]

n_obs <- function(x) sum(!is.na(x))

share5_ci_95_pct  <- share_5_ci_95  * 100
share65_ci_95_pct <- share_65_ci_95 * 100

ci_tbl <- tibble::tribble(
  ~Item,                             ~Time,     ~Mean,                                   ~`CI Low`,                 ~`CI High`,                ~`N (base)`,                                           ~Method,
  "Per-capita personal income",      "2019",    num1(per_capita_2019_ttest$estimate),    num1(per_capita_2019_ci_95[1]), num1(per_capita_2019_ci_95[2]), n_obs(data_counties$per_capita_personal_income_2019), "t-interval (mean)",
  "Per-capita personal income",      "2020",    num1(per_capita_2020_ttest$estimate),    num1(per_capita_2020_ci_95[1]), num1(per_capita_2020_ci_95[2]), n_obs(data_counties$per_capita_personal_income_2020), "t-interval (mean)",
  "Per-capita personal income",      "2021",    num1(per_capita_2021_ttest$estimate),    num1(per_capita_2021_ci_95[1]), num1(per_capita_2021_ci_95[2]), n_obs(data_counties$per_capita_personal_income_2021), "t-interval (mean)",
  "Bachelor degree share",           "2016–2019", num1(bachelor_ttest$estimate),         num1(bachelor_ci_95[1]),        num1(bachelor_ci_95[2]),        n_obs(data_counties$bachelor_degree_percentage_2016_2019), "t-interval (mean)",
  "Associate degree share",          "2016–2020", num1(associate_ttest$estimate),        num1(associate_ci_95[1]),       num1(associate_ci_95[2]),       n_obs(data_counties$associate_degree_percentage_2016_2020), "t-interval (mean)",
  "County population",               "2020",    num1(population_ttest$estimate),         num1(population_ci_95[1]),      num1(population_ci_95[2]),      n_obs(data_counties$POPESTIMATE),                       "t-interval (mean)",
  "Median age (years)",              "2020",    num1(median_age_ttest$estimate),         num1(median_age_ci_95[1]),      num1(median_age_ci_95[2]),      n_obs(data_counties$MEDIAN_AGE_TOT),                    "t-interval (mean)",
  "Population share under age 5 (%)","2020",    num1(share5 * 100),                      num1(share5_ci_95_pct[1]),      num1(share5_ci_95_pct[2]),      n_obs(data_counties$UNDER5_TOT),                         "t-interval (mean)",
  "Population share age 65+ (%)",    "2020",    num1(share65 * 100),                     num1(share65_ci_95_pct[1]),     num1(share65_ci_95_pct[2]),     n_obs(data_counties$AGE65PLUS_TOT),                      "t-interval (mean)"
) |>
  dplyr::mutate(
    Mean = round(as.numeric(Mean), 2),
    `CI Low` = round(as.numeric(`CI Low`), 4),
    `CI High` = round(as.numeric(`CI High`), 4),
    `N (base)` = as.integer(`N (base)`)
  )
# --- Save as PNG without Chrome/webshot ---
# install.packages(c("gridExtra","ragg"))
library(gridExtra)
library(grid)
library(ragg)
library(gtable)

row_fills <- rep(c("#FFFFFF", "#F7F7F7"), length.out = nrow(ci_tbl))

tbl_grob <- tableGrob(
  ci_tbl,
  rows = NULL,
  theme = ttheme_default(
    base_size = 10,
    core = list(
      bg_params = list(fill = row_fills, col = "grey70", lwd = 0.6),  # <- cell borders
      fg_params = list(cex = 0.9)                                     # text
    ),
    colhead = list(
      bg_params = list(fill = "#EDEDED", col = "grey70", lwd = 0.8),  # header borders
      fg_params = list(fontface = "bold")
    )
  )
)

# Set a reasonable image size based on number of rows
h_px <- 140 + 36 * nrow(ci_tbl)  # tune line height if needed
w_px <- 1200

agg_png("ci_summary_table.png", width = w_px, height = h_px, res = 150)
grid.newpage(); grid.draw(tbl_grob)
dev.off()

# If you also want to see it in the document:
grid.newpage(); grid.draw(tbl_grob)
```

**Per-capita income (2019–2021)**:

- ***The mean county per-capita income in 2019*** is estimated to lie between (`r scales::comma(round(per_capita_2019_ci_95[1], 2))`,`r scales::comma(round(per_capita_2019_ci_95[2], 2))`) (95% CI).

- ***For 2020***, the 95% CI is (`r scales::comma(round(per_capita_2020_ci_95[1], 2))`,`r scales::comma(round(per_capita_2020_ci_95[2], 2))`)

- ***For 2021***, it is (`r scales::comma(round(per_capita_2021_ci_95[1], 2))` , `r scales::comma(round(per_capita_2021_ci_95[2], 2))`).

The limited overlap across years indicates a statistically meaningful upward shift in the average county income.

**Population (mean per county)**:

- ***The mean county population*** is between (`r scales::comma(round(population_ci_95[1], 2))`,`r scales::comma(round(population_ci_95[2], 2))`) (95% CI). This is a wide band that reflects substantial heterogeneity across counties (very small rural counties vs large urban ones). This reflects the average county, not the national total. 

**Education**:

- ***Bachelor’s share*** (mean across counties): `r if (exists("bachelor_ci_95")) paste0("[", round(bachelor_ci_95[1],2), ", ", round(bachelor_ci_95[2],2), "]")`.

- ***Associate share *** (mean across counties): `r if (exists("associate_ci_95")) paste0("(", round(associate_ci_95[1],2), ", ", round(associate_ci_95[2],2), ")")`.

**Population composition (person-weighted) by age**:

- ***Median age*** (mean of county medians): The mean of county median ages lies between (`r round(median_age_ci_95[1], 2)`,`r round(median_age_ci_95[2], 2)`) (95% CI), characterizing the average county’s age profile. As we can see here, age profile is tight and middle-aged.


- ***Age 65+ overall share***: In the pooled population, the estimated share age 65+ is `r share65_population*100`%, with a 95% CI of (`r share65_ci_95_pct[1]`,`r share65_ci_95_pct[2]`). This is a population-weighted estimate (ratio of totals), so each person counts equally.

- ***Under 5 overall share***: The overall share under age 5 is `r share5_population*100`%, with a 95% CI of (`r share5_ci_95_pct[1]`,`r share5_ci_95_pct[2]`).


## Scatter plot to visualize correlation between our main variables

```{r}
ggplot(data_counties, aes(x = bachelor_degree_percentage_2016_2020, y = per_capita_personal_income_2020 )) +
  geom_point() +
  theme_minimal() +
  labs(
    title = "Bachelor’s Degree percentage vs. Per Capita Personal Income (2020) Scatter Plot",
    x = "Percentage of Bachelor's Degree 2016-2020",
    y = "Personal Income Per Capita (2020)"
  ) 

ggplot(data_counties, aes(x = associate_degree_percentage_2016_2020Test , y = per_capita_personal_income_2020 )) +
  geom_point() +
  theme_minimal() +
  labs(
    title = "Associate’s Degree percentage vs. Per Capita Personal Income (2020) Scatter Plot",
    x = "Percentage of Associate's Degree 2016-2020",
    y = "Personal Income Per Capita (2020)"
  ) 

```

Our scatter plot demonstrate that there is a slight positive correlation between bachelor degree percentage and per capita personal income. However, we can not see this trend in the associate degree percentage scatter plot, in fact we can hardly see any obvious correlation between associate percentage and per capita personal income.


### log log scatter plot

```{r scatterplot for bachlor percentage with respect to income , a log log relationship }

ggplot(data_counties, aes(x = log(bachelor_degree_percentage_2016_2020), y = log(No_Outlier_per_capita_personal_income_2020) )) +
  geom_point() +
  theme_minimal() +
  labs(
    title = "log of Bachelor’s Degree percentage vs. log of Per Capita Personal Income (2020) Scatter Plot",
    x = "log(Percentage of Bachelor's Degree 2016-2020)",
    y = "log(Personal Income Per Capita (2020))"
  ) 

```

```{r scatterplot for associate percentage with respect to income , a log log relationship}
ggplot(data_counties, aes(x = log(associate_degree_percentage_2016_2020Test), y = log(No_Outlier_per_capita_personal_income_2020) )) +
  geom_point() +
  theme_minimal() +
  labs(
    title = "log of Associate’s Degree percentage vs. log of Per Capita Personal Income (2020) Scatter Plot",
    x = "log(Percentage of Associate's Degree 2016-2020)",
    y = "log(Personal Income Per Capita (2020)"
  ) 

```

We draw the scatter plot again after remove extreme value from our per capita income columns and take natural log of both income and education data to smooth the distribution and demonstrate the percentage change relationship between two variables. We can still see a clearly upward sloped correlation between bachelor degree percentage and per capita income while the relationship between associate degree percentage and per capita income remain unclear. However, it is showing a slight upward slope on the scatterplot.



```{r Density Distribution of Per Capita Personal Income (2020)}
ggplot(data_counties, aes(x = per_capita_personal_income_2020)) +
  geom_density(fill = "blue", alpha = 0.6, color = "darkblue") +
  geom_vline(aes(xintercept = mean(per_capita_personal_income_2020, na.rm = T)), 
             color = "red", linetype = "dashed", size = 1) +
  theme_minimal() +
  labs(
    title = "Density Distribution of Per Capita Personal Income (2020)",
    subtitle = "The dashed red line indicates the mean.",
    x = "Per Capita Personal Income (2020)",
    y = "Density"
  )
```


```{r Density Distribution of Bachelors Degree Percentage}
ggplot(data_counties, aes(x = bachelor_degree_percentage_2015_2019)) +
  geom_density(fill = "green", alpha = 0.6, color = "darkgreen") +
  geom_vline(aes(xintercept = mean(bachelor_degree_percentage_2015_2019, na.rm = T)), 
             color = "red", linetype = "dashed", size = 1) +
  theme_minimal() +
  labs(
    title = "Density Distribution of Bachelor's Degree Percentage (2015-2019)",
    subtitle = "The dashed red line indicates the mean.",
    x = "Percentage of Population with a Bachelor's Degree",
    y = "Density"
  )
```

```{r Density Distribution of Associate Degree Percentage}

ggplot(data_counties, aes(x = associate_degree_percentage_2016_2020)) +
  
  geom_density(fill = "orange", alpha = 0.6, color = "darkorange") +
  
  geom_vline(aes(xintercept = mean(associate_degree_percentage_2016_2020, na.rm = TRUE)), 
             color = "red", linetype = "dashed", size = 1) +
  
  theme_minimal() +
  labs(
    title = "Density Distribution of Associate Degree Percentage (2016-2020)",
    subtitle = "The dashed red line indicates the mean.",
    x = "Percentage of Population with an Associate's Degree",
    y = "Density"
  )
```


The majority of the counties are concentrated at low income levels, and income is heavily skewed to the right. This occurs because the mean income in a small number of extremely wealthy counties is much higher than the median. A similar pattern can be seen in the bachelors degree percentage, which sharply peaks at 20%, indicating that fewer counties have extremely high educational levels. In contrast, the Associate's degree distribution is structurally different; it peaks later and more centrally, proving it represents a broader and more stable base of educational attainment across the U.S. counties.

# SMART Questions and Test

### Is there a statistically relationship between a county's economic income group and its college degree attainment group?


## Chi-squares Test:
The Chi-Square ($\chi^2$) test requires that we use categorical data, which means we must first group our numerical data (income and degree percentages) into discrete bins. We applied the Quantile Method to the 2020 Per-Capita Personal Income and the 2016-2020 degree percentages to create three approximately equal-sized categories for each variable: Low, Medium, and High. This approach ensured that about one-third of all counties fell into each group. Following this categorization, the $\chi^2$ test was applied to determine the statistical association between the categorized income levels and the educational attainment groups.



```{r  Chi-squares}

data_counties <- data_counties %>%
  mutate(income_cat = case_when(
      per_capita_personal_income_2020 < quantile(per_capita_personal_income_2020, 0.33, na.rm = TRUE) ~ "Low",
      per_capita_personal_income_2020 < quantile(per_capita_personal_income_2020, 0.67, na.rm = TRUE) ~ "Medium",
      TRUE ~ "High"),
      bachelor_cat = case_when(
      bachelor_degree_percentage_2015_2019 < quantile(bachelor_degree_percentage_2015_2019, 0.33, na.rm = TRUE) ~ "Low",
      bachelor_degree_percentage_2015_2019 < quantile(bachelor_degree_percentage_2015_2019, 0.67, na.rm = TRUE) ~ "Medium",
      TRUE ~ "High"),
      associate_cat = case_when(
      associate_degree_percentage_2016_2020 < quantile(associate_degree_percentage_2016_2020, 0.33, na.rm = TRUE) ~ "Low",
      associate_degree_percentage_2016_2020 < quantile(associate_degree_percentage_2016_2020, 0.67, na.rm = TRUE) ~ "Medium",
      TRUE ~ "High"))

data_counties$income_cat <- factor(data_counties$income_cat, 
  levels = c("Low", "Medium", "High"))

data_counties$bachelor_cat <- factor(data_counties$bachelor_cat, 
  levels = c("Low", "Medium", "High"))

data_counties$associate_cat <- factor(data_counties$associate_cat, 
  levels = c("Low", "Medium", "High"))


```


### Personal Income vs. Bachelor degree 
```{r}
# Chi-square test: 
chisq_income_bachelor <- chisq.test(table(data_counties$income_cat, data_counties$bachelor_cat))
chisq_income_bachelor

ggplot(data_counties, aes(x = income_cat, fill = bachelor_cat)) +
  geom_bar(position = "fill") +
  theme_minimal() +
  labs(title = "Bachelor's Degree Distribution by Income Category",
       x = "Income Category (2020)",
       y = "Proportion of Counties",
       fill = "Bachelor's Degree (%)") +
  scale_y_continuous(labels = scales::percent)
```


### Personal Income vs. Associate degree 
```{r}
chisq_income_associate <- chisq.test(table(data_counties$income_cat, data_counties$associate_cat))
chisq_income_associate

# Visualize income vs. associate's degree relationship
ggplot(data_counties, aes(x = income_cat, fill = associate_cat)) +
  geom_bar(position = "fill") +
  theme_minimal() +
  labs(title = "Associate's Degree Distribution by Income Category",
       x = "Income Category (2020)",
       y = "Proportion of Counties",
       fill = "Associate's Degree (%)") +
  scale_y_continuous(labels = scales::percent)
```

The χ2 tests verify that there is a strong correlation between a county's educational profile and economic health (p<0.001 for both). There is a statistically proven correlation between income and both the bachelor's and associate's degree categories.

The most important factor is the bachelor's degree, which has a stronger correlation with income (χ2≈1246) than an associate's degree (χ2≈151), by more than eight times. A bachelor's degree is the main prerequisite that structurally distinguishes high-income counties from all others, even though an associate's degree is helpful.


### Personal Income vs. Gender

**Hypotheses**

$H_{0}$: (independence): Gender composition is the same in every income quartile

$H_{1}$: Gender composition differs for at least one income quartile.

**Method**

- Break income quartiles from `per_capita_personal_income_2020` from Q1 to Q4.

- For each quartile, summed people by gender using `POPEST_MALE` and `POPEST_FEM`.

- Ran a Pearson χ² test of independence

**Method**:

```{r income vs gender}
inc_brks <- quantile(data_counties$per_capita_personal_income_2020, c(0, .25, .5, .75, 1), na.rm = TRUE)
inc_q <- cut(data_counties$per_capita_personal_income_2020, breaks = inc_brks, include.lowest = TRUE,
             labels = c("Q1 (lowest)","Q2","Q3","Q4 (highest)"))

ct_gender_income <- rbind(
  Male   = tapply(data_counties$POPEST_MALE,   inc_q, sum, na.rm = TRUE),
  Female = tapply(data_counties$POPEST_FEM,    inc_q, sum, na.rm = TRUE)
)

chi_gi <- chisq.test(ct_gender_income)
chi_gi
```


**Conclusion** 

Due to extremely small p-value, we ***reject $H_{0}$***. Gender and income quartile are not independent: the gender mix varies across income quartiles.

**Male/Female share by income quartiles**

```{r income vs gender graph}
prop_ct <- prop.table(ct_gender_income, margin = 2)  

par(mar = c(5, 5, 4, 8))  

bar_x <- barplot(
  prop_ct,
  beside = TRUE,
  col = c("steelblue", "pink"),
  main = "Population by Gender and Income Quartile",
  xlab = "Income Quartile",
  ylab = "Proportion",
  ylim = c(0, max(prop_ct)*1.1),
  las = 1)

legend(
  x = max(bar_x) + 1,  
  y = max(prop_ct),    
  legend = c("Male", "Female"),
  fill = c("steelblue", "pink"),
  xpd = TRUE)

```

```{r table of income share by gender}
quartiles <- colnames(ct_gender_income)

male   <- ct_gender_income["Male",   quartiles]
female <- ct_gender_income["Female", quartiles]
total  <- male + female

tbl_gender_income <- data.frame(
  `Income Quartile`  = quartiles,
  `Male Share (%)`   = round(100 * male   / total, 2),
  `Female Share (%)` = round(100 * female / total, 2),
  check.names = FALSE
)

knitr::kable(
  tbl_gender_income,
  row.names = FALSE,
  align = c("l","r","r"),
  caption = "Male/Female shares by income quartile (per-capita income 2020)."
)

```

### Personal Income vs. Median age

**Hypotheses**

$H_{0}$: (independence): Income-quartile and median-age–quartile are independent (county counts spread the same)

$H_{1}$: Median age differs for at least one income quartile.

```{r income vs age}

inc_brks <- quantile(data_counties$per_capita_personal_income_2020, c(0, .25, .5, .75, 1), na.rm = TRUE)
inc_q <- cut(data_counties$per_capita_personal_income_2020, breaks = inc_brks, include.lowest = TRUE,
             labels = c("Q1 (lowest)","Q2","Q3","Q4 (highest)"))


age_brks <- quantile(data_counties$MEDIAN_AGE_TOT, c(0, .25, .5, .75, 1), na.rm = TRUE)
age_q <- cut(data_counties$MEDIAN_AGE_TOT, breaks = age_brks, include.lowest = TRUE,
             labels = c("Q1","Q2","Q3","Q4"))

ct_income_age <- table(IncomeQuartile = inc_q, AgeQuartile = age_q)

chi_age <- chisq.test(ct_income_age)

prop_ct_age <- prop.table(ct_income_age, margin = 1)

par(mar = c(5, 5, 4, 8))
bar_x_age <- barplot(
  t(prop_ct_age),
  beside = TRUE,
  col = c("lightblue", "steelblue", "blue", "navy"),
  main = "Age Quartile Distribution by Income Quartile",
  xlab = "Income Quartile",
  ylab = "Proportion",
  ylim = c(0, max(prop_ct_age)*1.1),
  las = 1)

legend(
  x = max(bar_x_age) + 0.5,
  y = max(prop_ct_age),
  legend = c("Youngest",
             "Young Adults",
             "Middle-aged",
             "Oldest"),,
  fill = c("lightblue", "steelblue", "blue", "navy"),
  xpd = TRUE)

```
**Conclusion** 

We ***reject $H_{0}$***. Median age and income quartile are not independent: the median age varies across income quartiles. 

The graph shows a straightforward connection between age and how much money people make. As income levels go up, the share of the oldest group gets bigger, making them the largest group in the top-earning bracket (Q4). The opposite is true for younger people; they are most common in the lowest-earning group (Q1) and their share of the population tends to shrink in the higher-income brackets.
